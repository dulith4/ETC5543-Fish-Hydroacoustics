---
title: "Fish Hydroacoustics Project"
subtitle: "ETC5543 – Business Analytics Creative Activity"
author: "Dulitha Perera"
date: today
format:
  presentation-revealjs+letterbox:
    slide-number: true
    footer: "ETC5543 — Fish Hydroacoustics"
    incremental: false
    center: false
    margin: 0.06
    css: custom.scss
    smaller: true 
    
execute:
  echo: false
  warning: false
  message: false
execute-dir: project
resources:
  - presentation/media/model_pipeline.png
  - presentation/media/bg-deck.png

---

```{r}
#| label: setup
#| include: false
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
})

# Make sure we're resolving from the project root (the .Rproj is already there)
u_path <- here("Analysis", "utils_data.R")
if (!file.exists(u_path)) {
  stop("utils_data.R not found at: ", u_path,
       "\nWorking dir: ", getwd(),
       "\nTip: paths must be relative to the project root.")
}
source(u_path, local = TRUE)

fish_raw <- load_fish_transformed(
  raw_path  = here("data", "TSresponse_clean.RDS"),
  use_cache = TRUE,
  cache_path = here("outputs", "cache", "TS_clean_transformed.rds")
)

freq_cols <- names(fish_raw)[grepl("^F\\d+(?:\\.\\d+)?$", names(fish_raw))]
stopifnot(length(freq_cols) > 0)

```

```{r}

#| label: build-pipeline-svg
#| include: false
#| warning: false
#| message: false

library(DiagrammeR)
library(DiagrammeRsvg)

gr <- DiagrammeR::grViz("
digraph pipeline {
  graph [layout=dot, rankdir=LR, nodesep=0.45, ranksep=0.7]
  node [shape=box, style=\"rounded,filled\", color=\"#1b4965\", fillcolor=\"#cae9ff\",
        fontname=Helvetica, fontsize=14, margin=\"0.18,0.10\" ]

  raw   [label=<<B>1) Raw Sonar</B><BR/><FONT POINT-SIZE='12'>F45–F170 per ping</FONT>>]
  agg   [label=<<B>2) Per-fish Aggregation</B><BR/><FONT POINT-SIZE='12'>Quantiles (q20–q100)</FONT>>]
  feats [label=<<B>3) feasts Features</B><BR/><FONT POINT-SIZE='12'>ACF / PACF / STL (shape)</FONT>>]
  model [label=<<B>4) H2O AutoML</B><BR/><FONT POINT-SIZE='12'>GBM / Deep Learning / XGBoost</FONT>>]

  edge  [color=\"#003049\", penwidth=1.6, arrowhead=normal, arrowsize=0.9]
  raw   -> agg   [label=\" per fish \", fontsize=11]
  agg   -> feats [label=\" shape descriptors \", fontsize=11]
  feats -> model [label=\" features → classifier \", fontsize=11]

  /* keep the grouped-CV note only */
  note1 [shape=note, color=\"#577590\", fillcolor=\"#eaf4ff\",
         label=<<B>Grouped CV</B><BR/><FONT POINT-SIZE='11'>by fishNum (60/20/20)</FONT>>]

  {rank=same; agg; feats}
  agg -> note1 [style=dashed, arrowhead=none]
}
")

svg_txt   <- DiagrammeRsvg::export_svg(gr)
svg_nohdr <- sub("(?s)^.*?<svg", "<svg", svg_txt, perl = TRUE)

```


## What & Why fish hydroacoustics? {.larger}

:::: {.columns}
::: {.column width="58%"}
<div style="font-size: 1.25em; line-height: 1.35;">
- **Non-invasive** monitoring  
- **Traditionally**: hydroacoustics used to measure fish biological/behavioral features (size, depth, abundance) — **not to classify species**.
- **Management:** distinguish **LT** vs **SMB**  
- **Question:** can the **FRC (45–170 kHz)** classify species?  
- **Outcome:** scalable pipeline for species ID & trends
</div>
:::

::: {.column width="42%"}
![](media/sonar2.gif){width="100%" alt="Sonar echo demo"}
:::
::::



<style>
/* Make slide backgrounds transparent so the backdrop shows through */
.reveal .slides > section:not(.title-slide):not(#final),
.reveal .slides > section > section:not(#final) {
  background: transparent !important;
}
</style>




## About the dataset {.larger}
- ~**30k** observations × **302** variables; two species (**LT**, **SMB**)  
- Processed in **Echoview**  
- Signals: **F45–F170** (Frequency Response Curve)  
- Context: morphometrics, depth, speed, orientation  
- Focus today: **frequency data only** for classification

```{r}
#| fig-width: 9
#| fig-height: 4.8 
#| fig-align: left
#| 
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)

# Long form: one row per (species, frequency, TS)
freq_long <- fish_raw |>
  dplyr::select(species, dplyr::all_of(freq_cols)) |>
  tidyr::pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
  dplyr::mutate(frequency = readr::parse_number(frequency))

# Summarise per-species per-frequency quantiles
qdf <- freq_long |>
  group_by(species, frequency) |>
  summarise(
    q25  = quantile(TS, 0.25, na.rm = TRUE),
    q50  = quantile(TS, 0.50, na.rm = TRUE),
    q75  = quantile(TS, 0.75, na.rm = TRUE),
    q100 = max(TS, na.rm = TRUE),
    .groups = "drop"
  )

# For drawing the dashed quantile lines
q_lines <- qdf |>
  pivot_longer(q25:q100, names_to = "quant", values_to = "TSq")

# Aesthetic choices: species colors
cols_fill <- c("LT" = "#F7C6C6", "SMB" = "#BFECEF")   # light fills
cols_line <- c("LT" = "#E05A5A", "SMB" = "#1FBFCF")   # dashed lines

gg <- ggplot() +
  # Q25–Q75 shaded band
  geom_ribbon(
    data = qdf,
    aes(x = frequency, ymin = q25, ymax = q75, fill = species),
    alpha = 0.35, colour = NA
  ) +
  # Dashed lines at Q25, Q50, Q75, Q100
  geom_line(
    data = q_lines,
    aes(x = frequency, y = TSq, colour = species, linetype = quant),
    linewidth = 0.9
  ) +
  facet_wrap(~ species, nrow = 1, scales = "fixed") +
  scale_fill_manual(values = cols_fill, guide = "none") +
  scale_colour_manual(values = cols_line, guide = "none") +
  scale_linetype_manual(
    values = c(q25 = "dashed", q50 = "dashed", q75 = "dashed", q100 = "dashed"),
    labels = c(q25 = "Q25", q50 = "Q50 (median)", q75 = "Q75", q100 = "Q100 (max)")
  ) +
  labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Interactive plotly (hover shows frequency, quantile and TS value)
# Keep your gg object as-is above…

# Caption text (edit to taste)
cap_txt <- "Per-species FRC: ribbon = Q25–Q75; dashed = Q25/Q50/Q75/Q100"

ggplotly(
  gg,
  tooltip = c("x","y","quant")
) |>
  layout(
    # give a bit more top space for the caption
    margin = list(l = 90, r = 180, t = 86, b = 110),
    hovermode = "x unified",

    # axes (keep your auto margins so labels don't clip)
    xaxis  = list(title = "Frequency (kHz)",      automargin = TRUE),
    xaxis2 = list(title = "Frequency (kHz)",      automargin = TRUE),
    yaxis  = list(title = "Target Strength (dB)", automargin = TRUE),
    yaxis2 = list(title = "Target Strength (dB)", automargin = TRUE),

    # keep legend to the right
    legend = list(x = 1.02, y = 0.5, xanchor = "left", yanchor = "middle"),

    # --- top caption as an annotation ---
    annotations = list(list(
      text = cap_txt,
      x = 0.5, y = 1.08,                 # centered, just above the plot
      xref = "paper", yref = "paper",
      xanchor = "center", yanchor = "bottom",
      showarrow = FALSE,
      font = list(size = 12, color = "#444")
    ))
  ) |>
  config(responsive = TRUE, displayModeBar = FALSE)

```



## Acoustic fingerprints: the Frequency Response Curve (FRC) {.smaller .h2-smaller}

:::: {.columns}
::: {.column width="42%"}
- **Different echoes (45–170 kHz)** → the **FRC**
- **Summarised data**: using per-frequency summaries (mean ± SE) to reveal **clearer species patterns** and **reduce noise**
- Species show **distinct curve shapes**
- Hypothesis: **FRC alone** can separate LT vs SMB
:::

::: {.column width="58%"}
```{r}
#| label: fig-frc-species
#| fig-cap: "Mean Frequency Response Curve (FRC) with ±SE ribbon by species"
#| cap-location: top
#| fig-width: 7
#| fig-height: 5
#| fig-align: center

freq_long <- fish_raw |>
dplyr::select(species, dplyr::all_of(freq_cols)) |>
tidyr::pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
dplyr::mutate(frequency = readr::parse_number(frequency))

ggplot(freq_long, aes(frequency, TS, colour = species, fill = species)) +
stat_summary(fun = mean, geom = "line", linewidth = 1) +
stat_summary(fun.data = mean_se, geom = "ribbon", alpha = 0.18, colour = NA) +
labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
theme_minimal(base_size = 13) +
theme(legend.position = "bottom", plot.margin = margin(10,10,5,10))

```

:::
::::




## Which frequencies separate species? {.smaller .h2-smaller}

- Every Frequency **isn’t** equally useful for classification
- Better Classification by focusing on **discriminative frequencies**
- Future tuning: select **top discriminative frequencies** only


```{r}
#| label: fig-permimp-quintiles-allfreq
#| fig-width: 7
#| fig-height: 4.8
#| fig-align: center
#| out-width: 92%
#| warning: false
#| message: false
#| echo: false
#| cache: true

suppressPackageStartupMessages(library(h2o))

# silence the progress bars
h2o.no_progress()

# start or reuse H2O quietly (no console output)
invisible(capture.output({
  if (is.null(tryCatch(h2o.getConnection(), error = function(e) NULL))) {
    h2o.init(nthreads = -1, max_mem_size = "6G")  # <-- no 'quiet=' here
  }
}))

# 1) Load your latest StackedEnsemble MOJO saved by the tsfeatures script
mojo_paths <- list.files("outputs/models", pattern = "model\\.mojo\\.zip$", 
                         recursive = TRUE, full.names = TRUE)
mojo_paths <- mojo_paths[grepl("tsf_q_all|tsf_quint_all", mojo_paths)]
stopifnot(length(mojo_paths) > 0)
mojo_file <- mojo_paths[order(file.info(mojo_paths)$mtime, decreasing = TRUE)][1]
invisible(capture.output({ model <- h2o.import_mojo(mojo_file) }))

# 2) Load QUINTILES_ALLFREQ data + reproduce the same split (seed=73)
qa <- readRDS(here("outputs","tables","fish_quintiles_allfreq_tsfeat.rds"))

split_by_fish_strat <- function(df, p_train = 0.6, p_valid = 0.2, seed = 73) {
  stopifnot(all(c("fishNum","species") %in% names(df)))
  set.seed(seed)
  ids <- dplyr::distinct(df, fishNum, species)
  split_one <- function(di) {
    n <- nrow(di); idx <- sample.int(n)
    n_tr <- max(1, floor(p_train*n)); n_va <- max(1, floor(p_valid*n))
    n_te <- max(1, n - n_tr - n_va)
    while (n_tr + n_va + n_te > n) { if (n_tr > 1) n_tr <- n_tr - 1 else if (n_va > 1) n_va <- n_va - 1 else n_te <- n_te - 1 }
    tibble::tibble(fishNum = di$fishNum[idx],
                   split   = c(rep("train", n_tr), rep("valid", n_va), rep("test", n - n_tr - n_va)))
  }
  dplyr::bind_rows(lapply(dplyr::group_split(ids, species), split_one)) |>
    dplyr::right_join(df, by = "fishNum") |>
    dplyr::relocate(split)
}

sp      <- split_by_fish_strat(qa, seed = 73)
x_cols  <- setdiff(names(qa), intersect(names(qa), c("species","fishNum","quantile")))
test_df <- dplyr::select(dplyr::filter(sp, split == "test"), dplyr::all_of(c("species", x_cols)))

invisible(capture.output({ hex_te <- as.h2o(test_df) }))
hex_te[,"species"] <- h2o.asfactor(hex_te[,"species"])

# 3) Permutation importance for frequency bands only
freq_cols <- grep("^F\\d", x_cols, value = TRUE)

# helper: shuffle one H2O column in R and send it back (keeps the same name)
shuffle_col <- function(fr, col) {
  v <- as.data.frame(fr[, col])[[1]]
  h <- as.h2o(sample(v))
  colnames(h) <- col
  h
}

# baseline AUC on the unchanged test frame (silence performance output)
metric_auc <- function(mod, frame) {
  perf <- NULL
  invisible(capture.output({ perf <- h2o.performance(mod, frame) }))
  as.numeric(h2o.auc(perf))
}
auc_base <- metric_auc(model, hex_te)

# AUC drop when a single column is shuffled
perm_drop <- function(col) {
  all_cols <- colnames(hex_te)
  others   <- setdiff(all_cols, col)             # keep species + other predictors
  tmp <- h2o.cbind(hex_te[, others], shuffle_col(hex_te, col))
  auc_base - metric_auc(model, tmp)              # drop = baseline − shuffled
}

# compute importance for the frequency features you care about
imp <- tibble::tibble(
  variable = freq_cols,
  auc_drop = vapply(freq_cols, perm_drop, numeric(1))
) |> dplyr::arrange(dplyr::desc(auc_drop))

# optional: save for later
readr::write_csv(imp, "outputs/tables/varimp_quintiles_allfreq_permutation.csv")

# plot (top 20)
topn <- head(imp, 20)
ggplot2::ggplot(topn, ggplot2::aes(x = reorder(variable, auc_drop), y = auc_drop)) +
  ggplot2::geom_col() +
  ggplot2::coord_flip() +
  ggplot2::labs(
    x = NULL, y = "AUC drop when shuffled",
    title = "Frequency importance (permutation) — QUINTILES_ALLFREQ"
  ) +
  ggplot2::theme_minimal(base_size = 13)+
  ggplot2::coord_flip(clip = "off") +
  ggplot2::scale_y_continuous(expand = ggplot2::expansion(mult = c(0, 0.02)))


```



## From curves to models {.larger .h2-smaller}

- Each fish’s **FRC (45–170 kHz)** summarised  
  - **Quantiles** (q20–q100) 
- `feasts` features capture curve *shape* (ACF/PACF/STL) to encode smoothness, periodicity, and slope changes.(**treat** each fish’s FRC as a short time series)
- `H2O` `AutoML()` across Stack ensemble/GBM / DL / XGBoost
- Grouped CV by **fish**, test on **held-out** set

```{r}
#| label: show-pipeline
#| results: asis
#| echo: false

cat('<div style="text-align:center; margin: 0.75rem 0 1.25rem;">')
cat('<div style="display:inline-block; width:92vw; max-width:1200px;">')
cat(svg_nohdr)
cat('</div></div>')

```



## Baselines: RNN & per-ping AutoML {.larger}

**Pre-processing (used by the RNN):**

- Size-standardise each fish to **450 mm** with `offset_dB = 10*log10(450/length)`

- Convert **F45–F170** from dB → **linear backscatter**: `exp((dB + offset_dB)/10)`

- **Grouped splits** by *fishNum* (train / valid / test)

```{r baselines-table}
library(kableExtra)
options(knitr.kable.NA = "—")

baselines <- tribble(
~Model, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
"RNN (reproduction on 5-ping blocks)", 0.593, NA,     NA,
"AutoML (per-ping, original data)",     0.668, 0.7000, 0.663
)

# Rank rows: prefer Acc @ Policy (if present) else Acc @ 0.50

score_for_rank <- dplyr::coalesce(baselines$`Acc @ Policy`, baselines$`Acc @ 0.50`)
highlight_idx  <- which.max(score_for_rank)

baselines |>
mutate(
`Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
`Acc @ Policy` = ifelse(is.na(`Acc @ Policy`), "—", sprintf("%.3f", `Acc @ Policy`))
) |>
select(Model, `Acc @ 0.50`, `Acc @ Policy`) |>
kable(format = "html",
align  = c("l","r","r"),
caption = "Baselines on TEST set") |>
kable_styling(bootstrap_options = c("striped","hover","condensed"),
full_width = FALSE,
htmltable_class = "fit-table") |>
row_spec(highlight_idx, bold = TRUE, color = "#0B63CE")

```






## TS-features: AutoML (per-fish) {.larger}

**Four variants**

- **QUANTILES and ALL FREQUENCIES and TIME SERIES FEATURES** (5 rows/fish: F* + features)  
- **QUANTILES and TIME SERIES FEATURES** (5 rows/fish: features only)  
- **MEDIAN and ALL FREQUENCIES and TIME SERIES FEATURES** (1 row/fish: median F* + features)  
- **MEDIAN and TIME SERIES FEATURES** (1 row/fish: features only)

```{r tsfeatures-automl}
library(dplyr)
library(kableExtra)

ts_automl <- tribble(
~Variant, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
"QUINTILES_ALLFREQ", 0.883, 0.4754, 0.867,
"QUINTILES_FEATS",   0.633, 0.4000, 0.750,
"MEDIAN_ALLFREQ",    0.917, 0.5796, 0.833,
"MEDIAN_FEATS",      0.667, 0.4000, 0.750
)

# Highlight best by Acc @ Policy; fallback to Acc @ 0.50

score_for_rank <- dplyr::coalesce(ts_automl$`Acc @ Policy`, ts_automl$`Acc @ 0.50`)
highlight_idx  <- which.max(score_for_rank)

ts_automl |>
mutate(
`Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
`Acc @ Policy` = sprintf("%.3f", `Acc @ Policy`)
) |>
select(Variant, `Acc @ 0.50`, `Acc @ Policy`) |>
kable(format = "html",
align  = c("l","r","r"),
caption = "TS-features AutoML — TEST results") |>
kable_styling(bootstrap_options = c("striped","hover","condensed"),
full_width = FALSE,
htmltable_class = "fit-table") |>
row_spec(highlight_idx, bold = TRUE, color = "#0B63CE")

```



## Future Work: What’s next? {.bigger-future}

- **OOF (Out-of-Fold) Threshold Tuning** – to optimise classification thresholds 
- **Model Hyperparameter Tuning** – for the Deep Learning grid (layers, dropout, epochs, learning rate, etc.).  
- **Use discriminative frequencies**  
  Select F* bands that best separate LT vs SMB.  
  → Train compact models on these **top F* only** to reduce noise & overfitting.
- **Add richer time-series features from `tsfeatures/feasts`** 


<style>
/* Future Work slide — smaller, readable */
.reveal .slides section.bigger-future{
  font-size: 1.12em !important;      /* body text */
}
.reveal .slides section.bigger-future h2{
  font-size: 1.65em !important;      /* title smaller */
  line-height: 1.06 !important;
  margin-bottom: .30em !important;
}
.reveal .slides section.bigger-future li{
  margin-bottom: .30em !important;
}
</style>

</style>


## {#final .white}



<!-- Inline CSS scoped ONLY to this slide -->
<style>
/* scope to this slide by id so nothing else is touched */
.reveal section#final .closing-card{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  height:68vh; max-width:88vw; margin:6vh auto 0; padding:2.6rem 3.2rem;
  border-radius:30px;
  background:
    radial-gradient(1100px 540px at 30% 20%, rgba(255,255,255,.08), transparent 60%),
    radial-gradient(900px 700px at 70% 70%, rgba(255,255,255,.06), transparent 60%),
    linear-gradient(180deg, #0f2d43 0%, #092536 100%);
  box-shadow:0 22px 46px rgba(0,0,0,.28);
  color:#fff; text-align:center;
}
.reveal section#final .closing-card .q{
  margin:0;
  font-weight:900; line-height:1.18; letter-spacing:.2px;
  font-size:clamp(40px, 5.2vw, 72px);
  text-shadow:0 2px 8px rgba(0,0,0,.28);
}
.reveal section#final .closing-card .attr{
  margin-top:1rem; font-style:italic;
  font-size:clamp(18px, 2.2vw, 28px);
  text-shadow:0 1px 6px rgba(0,0,0,.28);
  opacity:.98;
}
/* kill any default paragraph spacing inside the card */
.reveal section#final .closing-card p{ margin:0; }
</style>

<div class="closing-card">
  <p class="q">Every fish leaves a sonic fingerprint.</p>
  <p class="q">Our job is to read it.</p>
  <p class="attr">Fish Hydroacoustics — ETC5543</p>
</div>
