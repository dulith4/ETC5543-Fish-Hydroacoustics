---
title: "Fish Hydroacoustics Project"
subtitle: "ETC5543 – Business Analytics Creative Activity"
author: "Dulitha Perera"
date: today
format:
  presentation-revealjs+letterbox:
    slide-number: true
    footer: "ETC5543 — Fish Hydroacoustics"
    incremental: false
    center: false
    margin: 0.06
    css: custom.scss
    smaller: true 
execute:
  echo: false
  warning: false
  message: false
execute-dir: project
resources:
  - presentation/media/model_pipeline.png

---

```{r}
#| label: setup
#| include: false
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
})

# Make sure we're resolving from the project root (the .Rproj is already there)
u_path <- here("Analysis", "utils_data.R")
if (!file.exists(u_path)) {
  stop("utils_data.R not found at: ", u_path,
       "\nWorking dir: ", getwd(),
       "\nTip: paths must be relative to the project root.")
}
source(u_path, local = TRUE)

fish_raw <- load_fish_transformed(
  raw_path  = here("data", "TSresponse_clean.RDS"),
  use_cache = TRUE,
  cache_path = here("outputs", "cache", "TS_clean_transformed.rds")
)

freq_cols <- names(fish_raw)[grepl("^F\\d+(?:\\.\\d+)?$", names(fish_raw))]
stopifnot(length(freq_cols) > 0)

```

```{r}
#| label: build-pipeline-svg
#| include: false
#| warning: false
#| message: false

library(DiagrammeR)
library(DiagrammeRsvg)

gr <- DiagrammeR::grViz("
digraph pipeline {
  graph [layout=dot, rankdir=LR, nodesep=0.45, ranksep=0.7]
  node [shape=box, style=\"rounded,filled\", color=\"#1b4965\", fillcolor=\"#cae9ff\",
        fontname=Helvetica, fontsize=14, margin=\"0.18,0.10\" ]
  raw   [label=<<B>1) Raw Sonar</B><BR/><FONT POINT-SIZE='12'>F45–F170 per ping</FONT>>]
  agg   [label=<<B>2) Per-fish Aggregation</B><BR/><FONT POINT-SIZE='12'>Quantiles (q20–q100) / Median</FONT>>]
  feats [label=<<B>3) feasts Features</B><BR/><FONT POINT-SIZE='12'>ACF / PACF / STL (shape)</FONT>>]
  model [label=<<B>4) H2O AutoML</B><BR/><FONT POINT-SIZE='12'>GBM / Deep Learning / XGBoost</FONT>>]
  edge  [color=\"#003049\", penwidth=1.6, arrowhead=normal, arrowsize=0.9]
  raw -> agg   [label=\" per fish \", fontsize=11]
  agg -> feats [label=\" shape descriptors \", fontsize=11]
  feats -> model [label=\" features → classifier \", fontsize=11]
  note1 [shape=note, color=\"#577590\", fillcolor=\"#eaf4ff\",
         label=<<B>Grouped CV</B><BR/><FONT POINT-SIZE='11'>by fishNum (60/20/20)</FONT>>]
  note2 [shape=note, color=\"#577590\", fillcolor=\"#eaf4ff\",
         label=<<B>Thresholds</B><BR/><FONT POINT-SIZE='11'>policy &amp; OOF clamp [0.40–0.70]</FONT>>]
  {rank=same; agg; feats}
  agg   -> note1 [style=dashed, arrowhead=none]
  model -> note2 [style=dashed, arrowhead=none]
}
")

svg_txt <- DiagrammeRsvg::export_svg(gr)

# Drop XML header/DOCTYPE so Reveal doesn’t show that text if it leaks
svg_nohdr <- sub("(?s)^.*?<svg", "<svg", svg_txt, perl = TRUE)

```




## Why fish hydroacoustics? {.larger .h2-smaller}

:::: {.columns}
::: {.column width="54%"}
- **Non-invasive** monitoring  
- **Management:** distinguish **LT** vs **SMB**  
- **Question:** can the **FRC (45–170 kHz)** classify species?  
- **Outcome:** scalable pipeline for species ID & trends
:::

::: {.column width="46%"}
![](media/sonar2.gif){width="100%" fig-align="center" alt="Animated sonar pulses bouncing off a fish"}
:::
::::


## About the dataset {.larger}
- ~**30k** rows × **302** variables; two species (**LT**, **SMB**)  
- Processed in **Echoview**  
- Signals: **F45–F170** (Frequency Response Curve)  
- Context: morphometrics, depth, speed, orientation  
- Focus today: **frequency data only** for classification




## Acoustic fingerprints: the Frequency Response Curve (FRC) {.smaller .h2-smaller}

:::: {.columns}
::: {.column width="42%"}
- **Different echoes (45–170 kHz)** → the **FRC**
- Species show **distinct curve shapes**
- Hypothesis: **FRC alone** can separate LT vs SMB
:::

::: {.column width="58%"}
```{r}
#| label: fig-frc-species
#| fig-width: 7
#| fig-height: 5
#| fig-align: center

freq_long <- fish_raw |>
  dplyr::select(species, dplyr::all_of(freq_cols)) |>
  tidyr::pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
  dplyr::mutate(frequency = readr::parse_number(frequency))

ggplot(freq_long, aes(frequency, TS, colour = species, fill = species)) +
  stat_summary(fun = mean, geom = "line", linewidth = 1) +
  stat_summary(fun.data = mean_se, geom = "ribbon", alpha = 0.18, colour = NA) +
  labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom", plot.margin = margin(5,5,0,5))
```

:::
::::




## Which frequencies separate species? {.smaller .h2-smaller}

- Compare **LT vs SMB** at each frequency (standardised difference)
- Peaks indicate **highly discriminative** frequencies

```{r}
#| label: fig-effectsize
#| fig-width: 7
#| fig-height: 4.2


# Ensure the sign is LT − SMB
fish_raw <- fish_raw |>
  mutate(species = factor(species, levels = c("LT","SMB")))

# Cohen's d (optionally bias-correct to Hedges' g)
effect_size <- function(x, g, hedges = FALSE) {
  x1 <- x[g == levels(g)[1]]
  x2 <- x[g == levels(g)[2]]
  n1 <- sum(!is.na(x1)); n2 <- sum(!is.na(x2))
  m1 <- mean(x1, na.rm = TRUE); m2 <- mean(x2, na.rm = TRUE)
  s1 <- stats::var(x1, na.rm = TRUE); s2 <- stats::var(x2, na.rm = TRUE)
  sp <- sqrt(((n1 - 1)*s1 + (n2 - 1)*s2) / (n1 + n2 - 2))
  d  <- (m1 - m2) / sp
  if (hedges) {
    J <- 1 - 3 / (4*(n1 + n2) - 9)
    d <- J * d
  }
  d
}

# Compute effect size at each frequency column
eff <- tibble(
  freq_khz = parse_number(freq_cols),
  d        = map_dbl(freq_cols, ~ effect_size(fish_raw[[.x]], fish_raw$species))
) |> arrange(freq_khz)

# Plot
ggplot(eff, aes(freq_khz, d)) +
  geom_hline(yintercept = 0, linewidth = 0.4, linetype = 2) +
  geom_line(linewidth = 0.9) +
  labs(
    x = "Frequency (kHz)",
    y = "Cohen's d (LT − SMB)"
  ) +
  theme_minimal(base_size = 13)
```




## From curves to models {.larger .h2-smaller}

- Each fish’s **FRC (45–170 kHz)** summarised  
  - **Quantiles** (q20–q100) & **Median**
- **feasts** features capture curve *shape* (ACF/PACF/STL)
- **H2O AutoML** across GBM / DL / XGBoost
- Grouped CV by **fish**, test on **held-out** set

```{r}
#| label: show-pipeline
#| results: asis
#| echo: false

cat('<div style="text-align:center; margin: 0.75rem 0 1.25rem;">')
cat('<div style="display:inline-block; width:92vw; max-width:1200px;">')
cat(svg_nohdr)
cat('</div></div>')

```



## Baselines: RNN & per-ping AutoML {.larger}

**Pre-processing (used by the RNN):**

- Size-standardise each fish to **450 mm** with `offset_dB = 10*log10(450/length)`

- Convert **F45–F170** from dB → **linear backscatter**: `exp((dB + offset_dB)/10)`

- **Grouped splits** by *fishNum* (train / valid / test)

```{r baselines-table}
library(kableExtra)
options(knitr.kable.NA = "—")

baselines <- tribble(
  ~Model, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
  "RNN (reproduction on 5-ping blocks)", 0.593, NA, NA,
  "AutoML (per-ping, original data)",     0.668, 0.7000, 0.663
)

baselines |>
  mutate(
    `Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
    `Policy thr`   = ifelse(is.na(`Policy thr`), "—", sprintf("%.4f", `Policy thr`)),
    `Acc @ Policy` = ifelse(is.na(`Acc @ Policy`), "—", sprintf("%.3f", `Acc @ Policy`))
  ) |>
  kable(format = "html", align = c("l","r","r","r"),
        caption = "Baselines on TEST set") |>
  kable_styling(bootstrap_options = c("striped","hover","condensed"),
                full_width = FALSE,
                htmltable_class = "fit-table")

```






## TS-features: AutoML (per-fish) {.larger}

**Four variants**

- **QUINTILES_ALLFREQ** (5 rows/fish: F* + tsfeatures)  
- **QUINTILES_FEATS** (5 rows/fish: tsfeatures only)  
- **MEDIAN_ALLFREQ** (1 row/fish: median F* + tsfeatures)  
- **MEDIAN_FEATS** (1 row/fish: tsfeatures only)

```{r tsfeatures-automl}
library(kableExtra)

ts_automl <- tribble(
  ~Variant, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
  "QUINTILES_ALLFREQ", 0.883, 0.4754, 0.867,
  "QUINTILES_FEATS",   0.633, 0.4000, 0.750,
  "MEDIAN_ALLFREQ",    0.917, 0.5796, 0.833,
  "MEDIAN_FEATS",      0.667, 0.4000, 0.750
)

ts_automl |>
  mutate(
    `Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
    `Policy thr`   = sprintf("%.4f", `Policy thr`),
    `Acc @ Policy` = sprintf("%.3f", `Acc @ Policy`)
  ) |>
  kable(format = "html", align = c("l","r","r","r"),
        caption = "TS-features AutoML — TEST results (policy = VALID max-ACC, clamped [0.40, 0.70])") |>
  kable_styling(bootstrap_options = c("striped","hover","condensed"),
                full_width = FALSE,
                htmltable_class = "fit-table")

```







## Threshold tuning: OOF vs baseline {.larger}

- 5-fold **grouped CV by fishNum**, pick threshold that maximises **OOF accuracy**, then **clamp** to **[0.40, 0.70]**  
- Compare TEST accuracy at **0.50** vs **OOF threshold**

```{r oof-table}
library(kableExtra)

oof <- tribble(
  ~Variant, ~`OOF thr (clip)`, ~`TEST Acc @ 0.50`, ~`TEST Acc @ OOF`,
  "QUINTILES_ALLFREQ", 0.4265, 0.867, 0.783,
  "QUINTILES_FEATS",   0.4000, 0.633, 0.633,
  "MEDIAN_ALLFREQ",    0.4000, 0.917, 1.000,
  "MEDIAN_FEATS",      0.7000, 0.750, 0.667
)

oof |>
  mutate(
    `OOF thr (clip)`  = sprintf("%.4f", `OOF thr (clip)`),
    `TEST Acc @ 0.50` = sprintf("%.3f", `TEST Acc @ 0.50`),
    `TEST Acc @ OOF`  = sprintf("%.3f", `TEST Acc @ OOF`)
  ) |>
  kable(format = "html", align = c("l","r","r","r"),
        caption = "OOF threshold tuning (5-fold grouped CV); clamp = [0.40, 0.70]") |>
  kable_styling(bootstrap_options = c("striped","hover","condensed"),
                full_width = FALSE,
                htmltable_class = "fit-table")

```





## Deep Learning grid (base-model tuning) {.larger}

- Tuned DL hyper-params (layers, dropout, epochs, LR/anneal, L1/L2).

- **Policy threshold fixed to 0.4000** (VALID max-ACC within clamp).

```{r dl-grid-table}
library(kableExtra)

dlgrid <- tribble(
  ~Variant, ~`TEST Acc @ 0.50`, ~`Policy thr`, ~`TEST Acc @ Policy`,
  "QUINTILES_ALLFREQ", 0.729, 0.4000, 0.743,
  "QUINTILES_FEATS",   0.786, 0.4000, 0.757,
  "MEDIAN_ALLFREQ",    0.857, 0.4000, 0.857,
  "MEDIAN_FEATS",      0.929, 0.4000, 0.929
)

dlgrid |>
  mutate(
    `TEST Acc @ 0.50`   = sprintf("%.3f", `TEST Acc @ 0.50`),
    `Policy thr`        = sprintf("%.4f", `Policy thr`),
    `TEST Acc @ Policy` = sprintf("%.3f", `TEST Acc @ Policy`)
  ) |>
  kable(format = "html", align = c("l","r","r","r"),
        caption = "Deep Learning grid — TEST results (policy fixed to 0.4000)") |>
  kable_styling(bootstrap_options = c("striped","hover","condensed"),
                full_width = FALSE,
                htmltable_class = "fit-table")

```


