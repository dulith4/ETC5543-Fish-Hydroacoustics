---
title: "Fish Hydroacoustics Project"
subtitle: "ETC5543 – Business Analytics Creative Activity"
author: "Dulitha Perera"
date: today
format:
  presentation-revealjs+letterbox:
    slide-number: true
    footer: "ETC5543 — Fish Hydroacoustics"
    incremental: false
    center: false
    margin: 0.06
    css: custom.scss
    smaller: true 
execute:
  echo: false
  warning: false
  message: false
execute-dir: project
resources:
  - presentation/media/model_pipeline.png

---

```{r}
#| label: setup
#| include: false
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
})

# Make sure we're resolving from the project root (the .Rproj is already there)
u_path <- here("Analysis", "utils_data.R")
if (!file.exists(u_path)) {
  stop("utils_data.R not found at: ", u_path,
       "\nWorking dir: ", getwd(),
       "\nTip: paths must be relative to the project root.")
}
source(u_path, local = TRUE)

fish_raw <- load_fish_transformed(
  raw_path  = here("data", "TSresponse_clean.RDS"),
  use_cache = TRUE,
  cache_path = here("outputs", "cache", "TS_clean_transformed.rds")
)

freq_cols <- names(fish_raw)[grepl("^F\\d+(?:\\.\\d+)?$", names(fish_raw))]
stopifnot(length(freq_cols) > 0)

```

```{r}
#| label: build-pipeline-svg
#| include: false
#| warning: false
#| message: false

library(DiagrammeR)
library(DiagrammeRsvg)

gr <- DiagrammeR::grViz("
digraph pipeline {
  graph [layout=dot, rankdir=LR, nodesep=0.45, ranksep=0.7]
  node [shape=box, style=\"rounded,filled\", color=\"#1b4965\", fillcolor=\"#cae9ff\",
        fontname=Helvetica, fontsize=14, margin=\"0.18,0.10\" ]
  raw   [label=<<B>1) Raw Sonar</B><BR/><FONT POINT-SIZE='12'>F45–F170 per ping</FONT>>]
  agg   [label=<<B>2) Per-fish Aggregation</B><BR/><FONT POINT-SIZE='12'>Quantiles (q20–q100)</FONT>>]
  feats [label=<<B>3) feasts Features</B><BR/><FONT POINT-SIZE='12'>ACF / PACF / STL (shape)</FONT>>]
  model [label=<<B>4) H2O AutoML</B><BR/><FONT POINT-SIZE='12'>GBM / Deep Learning / XGBoost</FONT>>]
  edge  [color=\"#003049\", penwidth=1.6, arrowhead=normal, arrowsize=0.9]
  raw -> agg   [label=\" per fish \", fontsize=11]
  agg -> feats [label=\" shape descriptors \", fontsize=11]
  feats -> model [label=\" features → classifier \", fontsize=11]
  note1 [shape=note, color=\"#577590\", fillcolor=\"#eaf4ff\",
         label=<<B>Grouped CV</B><BR/><FONT POINT-SIZE='11'>by fishNum (60/20/20)</FONT>>]
  note2 [shape=note, color=\"#577590\", fillcolor=\"#eaf4ff\",
         label=<<B>Thresholds</B><BR/><FONT POINT-SIZE='11'>policy &amp; OOF clamp [0.40–0.70]</FONT>>]
  {rank=same; agg; feats}
  agg   -> note1 [style=dashed, arrowhead=none]
  model -> note2 [style=dashed, arrowhead=none]
}
")

svg_txt <- DiagrammeRsvg::export_svg(gr)

# Drop XML header/DOCTYPE so Reveal doesn’t show that text if it leaks
svg_nohdr <- sub("(?s)^.*?<svg", "<svg", svg_txt, perl = TRUE)

```


## Why fish hydroacoustics? {.larger}

:::: {.columns}
::: {.column width="58%"}
<div style="font-size: 1.25em; line-height: 1.35;">
- **Non-invasive** monitoring  
- **Management:** distinguish **LT** vs **SMB**  
- **Question:** can the **FRC (45–170 kHz)** classify species?  
- **Outcome:** scalable pipeline for species ID & trends
</div>
:::

::: {.column width="42%"}
![](media/sonar2.gif){width="100%" alt="Sonar echo demo"}
:::
::::






## About the dataset {.larger}
- ~**30k** rows × **302** variables; two species (**LT**, **SMB**)  
- Processed in **Echoview**  
- Signals: **F45–F170** (Frequency Response Curve)  
- Context: morphometrics, depth, speed, orientation  
- Focus today: **frequency data only** for classification

```{r}
#| fig-width: 9
#| fig-height: 4.8 
#| fig-align: left
#| 
library(dplyr)
library(tidyr)
library(ggplot2)
library(plotly)

# Long form: one row per (species, frequency, TS)
freq_long <- fish_raw |>
  dplyr::select(species, dplyr::all_of(freq_cols)) |>
  tidyr::pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
  dplyr::mutate(frequency = readr::parse_number(frequency))

# Summarise per-species per-frequency quantiles
qdf <- freq_long |>
  group_by(species, frequency) |>
  summarise(
    q25  = quantile(TS, 0.25, na.rm = TRUE),
    q50  = quantile(TS, 0.50, na.rm = TRUE),
    q75  = quantile(TS, 0.75, na.rm = TRUE),
    q100 = max(TS, na.rm = TRUE),
    .groups = "drop"
  )

# For drawing the dashed quantile lines
q_lines <- qdf |>
  pivot_longer(q25:q100, names_to = "quant", values_to = "TSq")

# Aesthetic choices: species colors
cols_fill <- c("LT" = "#F7C6C6", "SMB" = "#BFECEF")   # light fills
cols_line <- c("LT" = "#E05A5A", "SMB" = "#1FBFCF")   # dashed lines

gg <- ggplot() +
  # Q25–Q75 shaded band
  geom_ribbon(
    data = qdf,
    aes(x = frequency, ymin = q25, ymax = q75, fill = species),
    alpha = 0.35, colour = NA
  ) +
  # Dashed lines at Q25, Q50, Q75, Q100
  geom_line(
    data = q_lines,
    aes(x = frequency, y = TSq, colour = species, linetype = quant),
    linewidth = 0.9
  ) +
  facet_wrap(~ species, nrow = 1, scales = "fixed") +
  scale_fill_manual(values = cols_fill, guide = "none") +
  scale_colour_manual(values = cols_line, guide = "none") +
  scale_linetype_manual(
    values = c(q25 = "dashed", q50 = "dashed", q75 = "dashed", q100 = "dashed"),
    labels = c(q25 = "Q25", q50 = "Q50 (median)", q75 = "Q75", q100 = "Q100 (max)")
  ) +
  labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )

# Interactive plotly (hover shows frequency, quantile and TS value)
# Keep your gg object as-is above…

ggplotly(
  gg,
  tooltip = c("x","y","quant")
) |>
  layout(
    # make room for facet strip titles (top) and axis titles (left/bottom)
    margin = list(l = 90, r = 180, t = 60, b = 110),
    hovermode = "x unified",
    # axis titles + auto margins so labels never get clipped
    xaxis  = list(title = "Frequency (kHz)",       automargin = TRUE),
    xaxis2 = list(title = "Frequency (kHz)",       automargin = TRUE),
    yaxis  = list(title = "Target Strength (dB)",  automargin = TRUE),
    yaxis2 = list(title = "Target Strength (dB)",  automargin = TRUE),
    # keep legend to the right so it doesn't fight the footer
    legend = list(x = 1.02, y = 0.5, xanchor = "left", yanchor = "middle")
  ) |>
  config(responsive = TRUE, displayModeBar = FALSE)

```



## Acoustic fingerprints: the Frequency Response Curve (FRC) {.smaller .h2-smaller}

:::: {.columns}
::: {.column width="42%"}
- **Different echoes (45–170 kHz)** → the **FRC**
- Species show **distinct curve shapes**
- Hypothesis: **FRC alone** can separate LT vs SMB
:::

::: {.column width="58%"}
```{r}
#| label: fig-frc-species
#| fig-width: 7
#| fig-height: 5
#| fig-align: center

freq_long <- fish_raw |>
  dplyr::select(species, dplyr::all_of(freq_cols)) |>
  tidyr::pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
  dplyr::mutate(frequency = readr::parse_number(frequency))

ggplot(freq_long, aes(frequency, TS, colour = species, fill = species)) +
  stat_summary(fun = mean, geom = "line", linewidth = 1) +
  stat_summary(fun.data = mean_se, geom = "ribbon", alpha = 0.18, colour = NA) +
  labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "bottom", plot.margin = margin(5,5,0,5))
```

:::
::::




## Which frequencies separate species? {.smaller .h2-smaller}

- Compare **LT vs SMB** at each frequency (standardised difference)
- Peaks indicate **highly discriminative** frequencies

```{r}
#| label: fig-effectsize
#| fig-width: 7
#| fig-height: 4.2


# Ensure the sign is LT − SMB
fish_raw <- fish_raw |>
  mutate(species = factor(species, levels = c("LT","SMB")))

# Cohen's d (optionally bias-correct to Hedges' g)
effect_size <- function(x, g, hedges = FALSE) {
  x1 <- x[g == levels(g)[1]]
  x2 <- x[g == levels(g)[2]]
  n1 <- sum(!is.na(x1)); n2 <- sum(!is.na(x2))
  m1 <- mean(x1, na.rm = TRUE); m2 <- mean(x2, na.rm = TRUE)
  s1 <- stats::var(x1, na.rm = TRUE); s2 <- stats::var(x2, na.rm = TRUE)
  sp <- sqrt(((n1 - 1)*s1 + (n2 - 1)*s2) / (n1 + n2 - 2))
  d  <- (m1 - m2) / sp
  if (hedges) {
    J <- 1 - 3 / (4*(n1 + n2) - 9)
    d <- J * d
  }
  d
}

# Compute effect size at each frequency column
eff <- tibble(
  freq_khz = parse_number(freq_cols),
  d        = map_dbl(freq_cols, ~ effect_size(fish_raw[[.x]], fish_raw$species))
) |> arrange(freq_khz)

# Plot
ggplot(eff, aes(freq_khz, d)) +
  geom_hline(yintercept = 0, linewidth = 0.4, linetype = 2) +
  geom_line(linewidth = 0.9) +
  labs(
    x = "Frequency (kHz)",
    y = "Cohen's d (LT − SMB)"
  ) +
  theme_minimal(base_size = 13)
```




## From curves to models {.larger .h2-smaller}

- Each fish’s **FRC (45–170 kHz)** summarised  
  - **Quantiles** (q20–q100) 
- **feasts** features capture curve *shape* (ACF/PACF/STL) to encode smoothness, periodicity, and slope changes.
- **H2O AutoML** across Stack ensemble/GBM / DL / XGBoost
- Grouped CV by **fish**, test on **held-out** set

```{r}
#| label: show-pipeline
#| results: asis
#| echo: false

cat('<div style="text-align:center; margin: 0.75rem 0 1.25rem;">')
cat('<div style="display:inline-block; width:92vw; max-width:1200px;">')
cat(svg_nohdr)
cat('</div></div>')

```



## Baselines: RNN & per-ping AutoML {.larger}

**Pre-processing (used by the RNN):**

- Size-standardise each fish to **450 mm** with `offset_dB = 10*log10(450/length)`

- Convert **F45–F170** from dB → **linear backscatter**: `exp((dB + offset_dB)/10)`

- **Grouped splits** by *fishNum* (train / valid / test)

```{r baselines-table}
library(kableExtra)
options(knitr.kable.NA = "—")

baselines <- tribble(
~Model, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
"RNN (reproduction on 5-ping blocks)", 0.593, NA,     NA,
"AutoML (per-ping, original data)",     0.668, 0.7000, 0.663
)

# Rank rows: prefer Acc @ Policy (if present) else Acc @ 0.50

score_for_rank <- dplyr::coalesce(baselines$`Acc @ Policy`, baselines$`Acc @ 0.50`)
highlight_idx  <- which.max(score_for_rank)

baselines |>
mutate(
`Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
`Acc @ Policy` = ifelse(is.na(`Acc @ Policy`), "—", sprintf("%.3f", `Acc @ Policy`))
) |>
select(Model, `Acc @ 0.50`, `Acc @ Policy`) |>
kable(format = "html",
align  = c("l","r","r"),
caption = "Baselines on TEST set") |>
kable_styling(bootstrap_options = c("striped","hover","condensed"),
full_width = FALSE,
htmltable_class = "fit-table") |>
row_spec(highlight_idx, bold = TRUE, color = "#0B63CE")

```






## TS-features: AutoML (per-fish) {.larger}

**Four variants**

- **QUINTILES_ALLFREQ** (5 rows/fish: F* + features)  
- **QUINTILES_FEATS** (5 rows/fish: features only)  
- **MEDIAN_ALLFREQ** (1 row/fish: median F* + features)  
- **MEDIAN_FEATS** (1 row/fish: features only)

```{r tsfeatures-automl}
library(dplyr)
library(kableExtra)

ts_automl <- tribble(
~Variant, ~`Acc @ 0.50`, ~`Policy thr`, ~`Acc @ Policy`,
"QUINTILES_ALLFREQ", 0.883, 0.4754, 0.867,
"QUINTILES_FEATS",   0.633, 0.4000, 0.750,
"MEDIAN_ALLFREQ",    0.917, 0.5796, 0.833,
"MEDIAN_FEATS",      0.667, 0.4000, 0.750
)

# Highlight best by Acc @ Policy; fallback to Acc @ 0.50

score_for_rank <- dplyr::coalesce(ts_automl$`Acc @ Policy`, ts_automl$`Acc @ 0.50`)
highlight_idx  <- which.max(score_for_rank)

ts_automl |>
mutate(
`Acc @ 0.50`   = sprintf("%.3f", `Acc @ 0.50`),
`Acc @ Policy` = sprintf("%.3f", `Acc @ Policy`)
) |>
select(Variant, `Acc @ 0.50`, `Acc @ Policy`) |>
kable(format = "html",
align  = c("l","r","r"),
caption = "TS-features AutoML — TEST results") |>
kable_styling(bootstrap_options = c("striped","hover","condensed"),
full_width = FALSE,
htmltable_class = "fit-table") |>
row_spec(highlight_idx, bold = TRUE, color = "#0B63CE")

```



## Future Work: Improving Model Performance

- **OOF (Out-of-Fold) Threshold Tuning** – to optimise classification thresholds 

- **Model Hyperparameter Tuning** – for the Deep Learning grid (layers, dropout, epochs, learning rate, etc.).  

- **Use discriminative frequencies**  
  Select F* bands that best separate LT vs SMB.  
  → Train compact models on these **top F* only** to reduce noise & overfitting.
- **Add richer time-series features from `tsfeatures/feasts`** 



## {#final} 

<!-- Inline CSS scoped ONLY to this slide -->
<style>
/* scope to this slide by id so nothing else is touched */
.reveal section#final .closing-card{
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  height:68vh; max-width:88vw; margin:6vh auto 0; padding:2.6rem 3.2rem;
  border-radius:30px;
  background:
    radial-gradient(1100px 540px at 30% 20%, rgba(255,255,255,.08), transparent 60%),
    radial-gradient(900px 700px at 70% 70%, rgba(255,255,255,.06), transparent 60%),
    linear-gradient(180deg, #0f2d43 0%, #092536 100%);
  box-shadow:0 22px 46px rgba(0,0,0,.28);
  color:#fff; text-align:center;
}
.reveal section#final .closing-card .q{
  margin:0;
  font-weight:900; line-height:1.18; letter-spacing:.2px;
  font-size:clamp(40px, 5.2vw, 72px);
  text-shadow:0 2px 8px rgba(0,0,0,.28);
}
.reveal section#final .closing-card .attr{
  margin-top:1rem; font-style:italic;
  font-size:clamp(18px, 2.2vw, 28px);
  text-shadow:0 1px 6px rgba(0,0,0,.28);
  opacity:.98;
}
/* kill any default paragraph spacing inside the card */
.reveal section#final .closing-card p{ margin:0; }
</style>

<div class="closing-card">
  <p class="q">Every fish leaves a sonic fingerprint.</p>
  <p class="q">Our job is to read it.</p>
  <p class="attr">Fish Hydroacoustics — ETC5543</p>
</div>
