---
title: "Classifying Lake Trout vs Smallmouth Bass from Wideband Hydroacoustics (45–170 kHz)"
subtitle: "ETC5543 — Business Analytics Creative Activity (Single-student project)"
author:
  - name: Dulitha Perera
    affiliation: Monash University — Econometrics & Business Statistics
supervisor: "Natalia Da Silva"
repository: "https://github.com/dulith4/ETC5543-Fish-Hydroacoustics"
bibliography: references.bib
execute-dir: project          

format:
  report-pdf:
    pdf-engine: lualatex
    include-in-header: header.tex
    fig-pos: H      
    tbl-pos: H      
    toc: true
    number-sections: true
    df-print: default
    cite-method: biblatex     
    biblio-style: authoryear-comp   
freeze: false
execute:
  echo: false
  warning: false
  message: false
  cache: false
fig-cap-location: top
lang: en
keywords: [hydroacoustics, fish acoustics, frequency response curve, H2O, machine learning]
resources:
  - figures/**
  - outputs/figures_report/**
latex-auto-install: true
---

```{r}
#| label: setup-root
#| include: false
library(here)
knitr::opts_knit$set(root.dir = here::here())
cat("Knit root.dir =", getwd(), "\n")

```


# Abstract

Wideband hydroacoustics enables non-invasive monitoring of fish populations, but reliable species-level identification remains challenging when visual confirmation is impossible. This project investigates whether frequency-only acoustic signals (45-170 kHz) can accurately distinguish Lake Trout (LT) and Smallmouth Bass (SMB). Building on earlier work that used a recurrent neural network (RNN) for the same dataset, we first replicate that baseline and then extend the analysis using a broader, leakage-safe machine-learning framework.

We summarise each fish’s frequency response curve (FRC) using quantiles and tsfeatures time-series descriptors, then apply H2O AutoML across multiple model families under grouped validation by fish identifier. The best model achieves strong out-of-sample performance (AUC almost 0.95; accuracy almost 0.90) with the upper-mid frequency band (140–160 kHz) contributing most to discrimination. Targeted tuning—via out-of-fold threshold optimisation, deep-learning grid search, and frequency-selector features—further improves test accuracy and interpretability.

Results demonstrate that wideband frequency-only signatures can separate species with high reliability, providing a reproducible and operationally deployable workflow for acoustic classification. All analyses are fully scripted in R using `renv` for dependency control and Git LFS for large data management.

#  Introduction & Motivation

Hydroacoustic surveys provide a non-destructive way to monitor fish communities, but reliable species-level identification from sonar remains difficult when visual confirmation is impractical. Wideband transducers measure target strength (TS) across many frequencies, giving each fish an acoustic “fingerprint” or frequency response curve (FRC). If these frequency-only signals can separate species accurately, managers can obtain species-resolved indices without netting or tagging.

Prior work (baseline). A related study on the same survey family applied several neural architectures—including fully-connected, convolutional, and recurrent neural networks (RNN/LSTM)—to size-standardised backscatter for species classification [@hydro_nn_internal_2025]. To ensure a fair comparison, we first replicate the RNN as a baseline (03a_rnn_reproduction.R) and also run AutoML on the same input representation (03_classification_original.R) to establish non-NN references. We then extend the methodology substantially.

**Our approach (replicate →→ extend).**

1. **Representation**. Summarise per-fish FRCs (45--170 kHz) using **quantiles** (q20–q100) and compute tsfeatures descriptors from short per-fish sequences, producing four datasets (quintiles/median x with/without raw F*).

2. **Model breadth**. Benchmark H2O families (GLM, RF, GBM, DeepLearning) via AutoML with grouped validation by fishNum to avoid leakage, reserving an unseen test set.

3. **Targeted tuning**. Convert the AutoML exploration to a single deployable model through out-of-fold threshold tuning (policy clamp [0.40,0.70][0.40,0.70]), a deep-learning grid for the top DL family, and frequency selectors (train-only top-K F*) to study which parts of the spectrum matter.

4. **Interpretability**. Quantify which frequencies drive separation and relate them to plausible mechanisms (e.g., bladder resonance, orientation).

**Contributions**.

A **frequency-only classification pipeline** with leakage-aware evaluation (grouped by fish/region) and a fixed operational threshold.

A **systematic representation study** (quantiles, tsfeatures, top-K F*) extending beyond the earlier RNN-only approach.

Clear **feature-importance** summaries highlighting discriminative frequency regions.

A **reproducible** R codebase (renv + Git LFS) with scripted outputs and one-shot execution.

**Research questions**

**Primary**
**RQ1**. Can Lake Trout vs Smallmouth Bass be classified **from FRC-only signals (45--170 kHz)** using **grouped validation** and an unseen test set, and how do results compare with the reproduced RNN baseline?

**Secondary**
**RQ2**. Which **frequency regions** and **representations** (band means/ratios, PCA of FRC, tsfeatures, top-K F*) contribute most to separation?

**RQ3**. What **descriptive** depth/orientation/behaviour patterns accompany species labels (not used for prediction)?

**RQ4**. What are the key **limitations** (orientation, sampling bias, leakage risks) and how should future surveys/classifier deployment adapt?

  **Non-goals**. We do **not** use morphometrics (length/weight) for prediction; temporal/spatial analyses are **descriptive only**.
  
#  Data & Preparation

## **Source and structure**

The dataset is provided as an RDS file (`TSresponse_clean.RDS`, tracked via Git LFS) with over **30k** rows and **302** variables. Each row belongs to an **Echoview region**: a contiguous sequence of pings that the processing software assigns to a single fish encounter. Two identifiers link the data:

- `fishNum` — unique individual; LT/SMB prefix encodes species.

- `Region_name` — encounter identifier within a fish.

The block `F45..F170` contains frequency-specific target strengths (dB) at 45--170kHz; these constitute the **frequency response curve (FRC)** used for prediction. Additional variables describe geometry/behaviour (e.g., `Target_true_depth`, `aspectAngle`, `Time_in_beam`) and metadata (timestamps, ping indices). A concise glossary appears in Appendix A.

## **Scope decisions**

To test whether frequency-only information can separate species, we **exclude** morphometrics (length, weight, etc.) from all predictive models. Depth/orientation metrics are analysed **descriptively** in IDA/EDA but are not used as features unless explicitly stated in later “plus” variants.

## **Cleaning and basic checks**

We perform light cleaning before feature construction:

1. **Type & order**. Ensure `F*` columns are numeric and ordered by frequency; drop corrupted rows.

2. **Species label**. Standardise to two classes: Lake Trout (LT) and Smallmouth Bass (SMB).

3. **Duplicates**. Remove any accidental duplicate rows (exact key or repeated ping).

4. **Sanity checks**. Count per-species records; check frequency coverage and missingness across `F*`.

(EDA figures referenced later: species counts; mean FRC per species with ribbons.)

## **Fish-level representations (what we train on)**

Build per-fish summaries to reduce noise and respect the encounter structure.

- **Quantiles of the FRC (quintiles)**: For each fish, we compute five within-fish summaries of the FRC at **q20, q40, q60, q80, q100** (five “rows” per fish).

  - Output artifact: `outputs/tables/fish_freq_quintiles_long.rds`.

  - This retains frequency resolution (columns `F45..F170`) while stabilising per-ping variability.

- **Median FRC**: A single row per fish using the within-fish median of each `F*`.

Used to create compact, one-row-per-fish variants.

- **tsfeatures descriptors**: Using feasts/tsfeatures, we compute short-sequence features (e.g., ACF summaries) from per-fish frequency traces. We produce four datasets:

  1. **quintiles_allfreq_tsfeat** — 5 rows/fish: raw `F*` + tsfeatures

  2. **quintiles_tsfeat_only** — 5 rows/fish: tsfeatures only

  3. **median_allfreq_tsfeat** — 1 row/fish: median `F*` + tsfeatures

  4. **median_tsfeat_only** — 1 row/fish: tsfeatures only

Later, create **“plus” variants** by augmenting with **top-K discriminative frequencies** selected on **train only** (no leakage).

## **Train/validation/test design (leakage-aware)**

- **Grouping**. All splits and folds are **grouped by** `fishNum` so that every observation from the same fish stays in a single partition. For quintile datasets, the five rows per fish move together.

- **Stratification**. Within groups, we stratify by species to maintain balance.

- **Holdout**. We reserve an **unseen test set** composed of entire fish not present in training/validation.

- **Cross-validation**. Model selection uses grouped k-fold CV (typically k=5).

- **Seed**. A fixed seed (73) is used for reproducibility.

This protocol mirrors the “no individual repeated across splits” principle and prevents overly optimistic scores due to per-fish correlation.

## **Preprocessing for modelling**

- **Predictors**. Unless stated otherwise, features are the FRC block (`F45..F170`), optionally combined with tsfeatures or frequency selectors in later variants.

- **Standardisation**. Where model families benefit (e.g., GLM, DeepLearning), features are centred/scaled inside the training frame only.

- **Class label**. `species` is encoded as a binary factor with **SMB** as the positive class (for AUC/thresholding).

- **Artifacts**. Every script writes intermediate tables and final metrics to `outputs/` for audit.

## **Reproducibility**

- **Environment**. The repository uses renv; `renv.lock` specifies exact package versions.

- **Large files**. The RDS data and any large artifacts are tracked via **Git LFS**.

- **One-shot run**. `analysis/run_all.R` reproduces the entire pipeline end-to-end.

- **Fixed randomness**. All random processes (splits, AutoML seeds) use the project seed 73.

#  **Initial Data Analysis (IDA/EDA)**

```{r}
#| label: setup-dirs
#| echo: false
#| output: false
dir.create(here::here("outputs","cache"), recursive = TRUE, showWarnings = FALSE)

```


```{r}
#| echo: false
#| output: false
#| label: fig-path-check
getwd()
list.files("figures")
file.exists("figures/hydro.png")
file.exists(here::here("reports","figures","hydro.png"))

```


```{r}
#| label: setup-eda
#| include: false
#| message: false
#| warning: false

library(tidyverse); library(here)

# Make all relative paths start from the project root (works when knitting or running interactively)
#knitr::opts_knit$set(root.dir = here::here())

# Locate utils_data.R regardless of folder casing
utils_path <- if (file.exists(here::here("analysis", "utils_data.R"))) {
  here::here("analysis", "utils_data.R")
} else if (file.exists(here::here("Analysis", "utils_data.R"))) {
  here::here("Analysis", "utils_data.R")
} else {
  stop("Cannot find utils_data.R. Check that it exists in 'analysis/' (or 'Analysis/').")
}

source(utils_path)

# Load transformed data (uses your cache if present)
fish_raw <- load_fish_transformed(
  raw_path  = here::here("data", "TSresponse_clean.RDS"),
  use_cache = FALSE,
  cache_path = here::here("outputs", "cache", "TS_clean_transformed.rds")
)

# Frequency columns, including decimals like F45.5
freq_cols <- names(fish_raw)[stringr::str_detect(names(fish_raw), "^F\\d+(?:\\.\\d+)?$")]
stopifnot(length(freq_cols) > 0)

# Ensure species is LT/SMB factor
if (!"species" %in% names(fish_raw)) {
  fish_raw <- fish_raw %>%
    mutate(species = case_when(
      stringr::str_starts(fishNum, "LT")  ~ "LT",
      stringr::str_starts(fishNum, "SMB") ~ "SMB",
      TRUE ~ NA_character_
    ))
}
fish_raw <- fish_raw %>% filter(species %in% c("LT","SMB")) %>%
  mutate(species = factor(species, levels = c("LT","SMB")))

```

The dataset contains a moderate imbalance between the two species.  
Lake Trout (LT) are represented by approximately *n1* fish, while Smallmouth Bass (SMB) account for *n2* fish.  

Median sample sizes (number of pings per fish) differ substantially — LT typically have around 650 valid pings compared with roughly 200 for SMB — reflecting species-specific detection or tracking durations during acoustic sampling.  
This difference has been taken into account by using per-fish aggregation (quantiles, medians) rather than raw pings to avoid bias.



```{r}
#| label: tbl-balance
#| tbl-cap: "Class balance and per-fish sample size (pings)."
#| echo: false
library(dplyr)
library(knitr)

pings_per_fish <- fish_raw %>%
  count(fishNum, species, name = "n_pings")   

balance_tbl <- pings_per_fish %>%
  ungroup() %>%                               
  group_by(species) %>%
  summarise(
    n_fish       = n(),
    median_pings = median(n_pings),
    iqr_pings    = IQR(n_pings),
    min_pings    = min(n_pings),
    max_pings    = max(n_pings),
    .groups = "drop"
  ) %>%
  mutate(
    prop = n_fish / sum(n_fish),
    prop = round(prop, 3)                     
  )

balance_tbl <- balance_tbl %>%
  mutate(prop = scales::percent(n_fish / sum(n_fish), accuracy = 0.1))

knitr::kable(balance_tbl) 

```








```{r}
#| label: fig-pca-frc
#| fig-cap: "PCA of median FRC (one point per fish). Species separate along PC1/PC2."
#| fig-width: 6.8
#| fig-height: 5.2
library(dplyr)

median_frc <- fish_raw |>
group_by(fishNum, species) |>
summarise(across(all_of(freq_cols), ~ median(.x, na.rm = TRUE)), .groups = "drop")

X <- median_frc |> select(all_of(freq_cols)) |> as.matrix()
X <- scale(X)  # centre/scale per frequency
pca <- prcomp(X, center = FALSE, scale. = FALSE)

scores <- as_tibble(pca$x[, 1:2]) |>
bind_cols(median_frc |> select(species))

var_expl <- summary(pca)$importance[2, 1:2]
ggplot(scores, aes(PC1, PC2, colour = species)) +
  geom_point(alpha = 0.8) +
  labs(
    x = sprintf("PC1 (%.0f%%)", 100*var_expl[1]),
    y = sprintf("PC2 (%.0f%%)", 100*var_expl[2])
  ) +
  theme_minimal(base_size = 12) +
  theme(legend.position = "bottom")


```


The PCA of the median frequency response curves (FRCs) shows clear separation between Lake Trout (LT) and Smallmouth Bass (SMB) along the first two principal components (PC1 and PC2).  
PC1 explains about 61% of total variance and captures the overall amplitude differences in backscatter strength, while PC2 (21%) reflects finer variations in frequency-dependent patterns.  
The clustering of points by species indicates that most discriminatory information is captured by the leading components, confirming that frequency-only data already contain strong species-level signals before any supervised modelling.







## **What is fish hydroacoustics?**

Fish hydroacoustics is the study of how sound waves interact with fish underwater.
A transducer emits sound pulses (pings) and records the returning echoes—how strongly a fish reflects sound depends on its body shape, tissue composition, and especially the gas-filled swim bladder.
Each fish produces a unique pattern of backscatter strength across frequencies, known as a Frequency Response Curve (FRC).
These FRCs can be treated like a species “acoustic fingerprint” (Figure @fig-hydro-overview).

![](figures/hydro.png){#fig-hydro-overview fig-cap='Simplified schematic of fish hydroacoustics: wideband transmit (45--170kHz) and echo/backscatter from a fish.' fig-align="center" width=70%}



## **Why use hydroacoustics for classification?**

Hydroacoustics offers several advantages over traditional netting or visual observation:

- **Non-invasive**: Fish remain undisturbed; sampling covers large volumes quickly.

- **Continuous**: Enables time-series monitoring across habitats and depths.

- **Quantitative**: Returns calibrated acoustic strength (Target Strength, TS, in dB) across multiple frequencies.

Because the FRC shape reflects biological differences (e.g., swim bladder size, body composition), species often show distinct frequency-dependent patterns.
Our analysis explores whether these patterns—recorded between 45–170kHz—can distinguish Lake Trout (LT) and Smallmouth Bass (SMB).

## **Quantile envelopes**

We first examine the **raw distribution of target strengths (TS)** across frequencies to understand within-species variability.
Figure @fig-frc-quantiles presents **per-species quantile envelopes**, where the shaded band captures the interquartile range (Q25–Q75) and dashed lines indicate additional quantiles (Q25, Q50, Q75, Q100).
The clear vertical offset between Lake Trout (LT) and Smallmouth Bass (SMB) across most of the spectrum shows that separation is not driven by a few extreme observations — instead, the difference is consistent throughout each frequency range.
This highlights that species differences are evident even before aggregation, reflecting genuine signal-level distinctions in acoustic response.

```{r}
#| label: fig-frc-quantiles
#| fig-cap: "Frequency-response quantiles by species. Shaded bands show Q25–Q75 with the solid line as the median; dashed lines are Q25 and Q75; dotted lines show min and max. Between-species offsets persist across the full band, with the clearest separation in the upper-mid range (140–160 kHz)."
#| fig-width: 9
#| fig-height: 4.8
#| fig-align: center

freq_long <- fish_raw |>
select(species, all_of(freq_cols)) |>
pivot_longer(-species, names_to = "frequency", values_to = "TS") |>
mutate(frequency = readr::parse_number(frequency))

qdf <- freq_long |>
  group_by(species, frequency) |>
  summarise(
    q0   = min(TS, na.rm = TRUE),
    q25  = quantile(TS, 0.25, na.rm = TRUE),
    q50  = quantile(TS, 0.50, na.rm = TRUE),
    q75  = quantile(TS, 0.75, na.rm = TRUE),
    q100 = max(TS, na.rm = TRUE),
    .groups = "drop"
  )

q_lines <- qdf |>
  pivot_longer(q0:q100, names_to = "quant", values_to = "TSq")

cols_fill <- c("LT" = "#F7C6C6", "SMB" = "#BFECEF")
cols_line <- c("LT" = "#E05A5A", "SMB" = "#1FBFCF")

ggplot() +
  geom_ribbon(
    data = qdf,
    aes(x = frequency, ymin = q25, ymax = q75, fill = species),
    alpha = 0.35, colour = NA
  ) +
  geom_line(
    data = filter(q_lines, quant %in% c("q25","q50","q75")),
    aes(x = frequency, y = TSq, colour = species, linetype = quant),
    linewidth = 1
  ) +
  geom_line(  # draw min/max lighter & thinner so they don't dominate
    data = filter(q_lines, quant %in% c("q0","q100")),
    aes(x = frequency, y = TSq, colour = species),
    linetype = "dotted", linewidth = 0.6, alpha = 0.6
  ) +
  facet_wrap(~ species, nrow = 1, scales = "fixed") +
  scale_fill_manual(values = cols_fill, guide = "none") +
  scale_colour_manual(values = cols_line, guide = "none") +
  scale_linetype_manual(
    values = c(q25 = "dashed", q50 = "solid", q75 = "dashed"),
    labels = c(q25 = "Q25", q50 = "Median", q75 = "Q75")
  ) +
  guides(linetype = guide_legend(title = NULL, nrow = 1)) +
  labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
  coord_cartesian(ylim = c(-120, -20)) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    legend.position = "bottom"
  )


```


## **Mean frequency response by species**

After examining the full distribution, we next summarise the data to compare **average acoustic profiles between species**.
Figure @fig-frc-species shows the **mean target strength (TS)** at each frequency with a shaded **standard error (SE)** ribbon.
The two mean curves diverge most noticeably in the **low-frequency band (50–120 kHz)** and again in the **upper–mid band (140–160 kHz)**, suggesting that these regions carry the most discriminative information for species separation.
These frequency bands will later correspond to the model-derived importance peaks, reinforcing that the strongest signals in the raw data also drive predictive performance.

```{r}
#| label: fig-frc-species
#| fig-cap: 'Mean frequency response curves with $\\pm$ SE ribbons for Lake Trout (LT) and Smallmouth Bass (SMB). Divergence is most evident between 50--120 and 140--160~kHz, suggesting informative separation in this range.'


#| fig-width: 7
#| fig-height: 5
#| fig-align: center


ggplot(freq_long, aes(frequency, TS, colour = species, fill = species)) +
stat_summary(fun = mean, geom = "line", linewidth = 1) +
stat_summary(fun.data = mean_se, geom = "ribbon", alpha = 0.18, colour = NA) +
labs(x = "Frequency (kHz)", y = "Target Strength (dB)") +
theme_minimal(base_size = 13) +
theme(legend.position = "bottom", plot.margin = margin(5,5,0,5))

```





## **Effect size by frequency**

Figure @fig-effectsize shows Cohen’s d values comparing Lake Trout (LT) and Smallmouth Bass (SMB) at each frequency between 45–170 kHz.
Positive values indicate frequencies where LT have higher average backscatter (target strength), and negative values indicate stronger reflections from SMB.

The plot reveals **moderate effect sizes** (0.2–0.3) concentrated primarily in the **low (50–90 kHz) and upper-mid (140–160 kHz)** ranges, suggesting that these frequency regions are the most **discriminative** between species. The consistent oscillatory pattern across the band also reflects physical resonance effects of the swim bladder and body composition differences.

Later in **Section 5.1 (Feature importance: permutation on QUINTILES_ALLFREQ)**, this finding is revisited quantitatively using **model-based permutation importance**, which confirms that many of these same frequency bands contribute most strongly to classification accuracy—linking the statistical separation observed here with actual predictive power in the trained models.

```{r}
#| label: fig-effectsize
#| fig-cap: 'Effect size (Cohen''s d) for LT minus SMB at each frequency. Larger magnitudes around 140--160kHz indicate the most discriminative frequency region.'
#| fig-width: 7
#| fig-height: 4.2
#| fig-align: center


fish_raw <- fish_raw |> mutate(species = factor(species, levels = c("LT", "SMB")))

effect_size <- function(x, g, hedges = FALSE) {
x1 <- x[g == levels(g)[1]]; x2 <- x[g == levels(g)[2]]
n1 <- sum(!is.na(x1)); n2 <- sum(!is.na(x2))
m1 <- mean(x1, na.rm = TRUE); m2 <- mean(x2, na.rm = TRUE)
s1 <- stats::var(x1, na.rm = TRUE); s2 <- stats::var(x2, na.rm = TRUE)
sp <- sqrt(((n1 - 1)*s1 + (n2 - 1)*s2) / (n1 + n2 - 2))
d  <- (m1 - m2) / sp
if (hedges) d <- (1 - 3 / (4*(n1 + n2) - 9)) * d
d
}

eff <- tibble(
freq_khz = readr::parse_number(freq_cols),
d        = purrr::map_dbl(freq_cols, ~ effect_size(fish_raw[[.x]], fish_raw$species))
) |> arrange(freq_khz)

ggplot(eff, aes(freq_khz, d)) +
geom_hline(yintercept = 0, linewidth = 0.4, linetype = 2, colour = "grey50") +
geom_line(linewidth = 0.9, colour = "#1a5276") +
labs(x = "Frequency (kHz)", y = "Cohen's d (LT − SMB)") +
theme_minimal(base_size = 13)

```






#  Feature Engineering

Transform each fish’s wideband frequency-response curve (FRC; 45–170 kHz) into stable, leakage-safe features for classification.

**(a) Per-fish quintiles (five rows per fish).**

Using `Analysis/02b_fish_quantiles.R`, we summarise each fish’s within-fish distribution at five quantiles **q20, q40, q60, q80, q100** while preserving frequency resolution (`F*` columns). This reduces per-ping noise but keeps the FRC shape. Output: outputs/tables/fish_freq_quintiles_long.rds.

**(b) Time-series descriptors of FRC shape.**
Treat each fish’s FRC as a short “series” across frequency and compute descriptors with feasts (ACF/PACF, STL, spectral) and, when available, tsfeatures (entropy, lumpiness, stability, unit-root tests, etc.). Sure — here’s a short, clear version you can drop right under your subheading:

Each fish’s FRC is treated as a short *pseudo–time series* because backscatter values are ordered across frequency, not randomly scattered. This ordering allows us to use time-series descriptors (e.g., ACF, PACF, spectral features) to quantify how smoothly or abruptly the response changes across frequencies.




- `Analysis/03b_features_fish_level.R` builds ACF-style features and pivots to **one row per fish**.

- `Analysis/04_tsfeatures_build.R` and `Analysis/04e_tsfeatures_plus.R` (Tuning purpose) produce four standard variants (quintiles vs median; with/without raw `F*`) and their “+” versions (feasts + tsfeatures).


**(c) Combined representations used downstream.**

Benchmark four families of inputs (each later fed to H2O/AutoML):

  1. **quintiles_allfreq_tsfeat** — 5 rows/fish: raw `F*` + descriptors

  2. **quintiles_tsfeat_only** — 5 rows/fish: descriptors only

  3. **median_allfreq_tsfeat** — 1 row/fish: median `F*` + descriptors

  4. **median_tsfeat_only** — 1 row/fish: descriptors only
  
  “Plus” variants add extra tsfeatures (entropy, stability, unit-root, etc.).

**(d) Standardisation.**

For GLM/DeepLearning we centre/scale predictors inside the training frame; tree models use raw scales.

**(e) Frequency selection (diagnostic, train-only).**

We also explore **Top-K frequency selectors** guided by permutation importance (see Results S 7.1). Selectors are fit on **training only** to avoid leakage and then applied to validation/test.


## **Datasets produced (inventory)**

```{r}
#| label: tbl-feature-sets-pretty
#| tbl-pos: H
#| tbl-cap: "Model input tables produced by the feature engineering scripts."
#| echo: false
#| message: false
#| warning: false

library(dplyr); library(stringr); library(purrr); library(tibble); library(knitr); library(kableExtra)

brief <- function(path, id_cols = c("fishNum","species","quantile","n")) {
  if (!file.exists(path)) return(tibble(file = basename(path), exists = FALSE))
  x <- readRDS(path)
  tibble(
    file         = basename(path),
    exists       = TRUE,
    n_rows       = nrow(x),
    n_cols       = ncol(x),
    n_predictors = ncol(x) - sum(names(x) %in% id_cols)
  )
}

paths <- c(
  "outputs/tables/fish_quintiles_allfreq_tsfeat.rds",
  "outputs/tables/fish_quintiles_tsfeat_only.rds",
  "outputs/tables/fish_median_allfreq_tsfeat.rds",
  "outputs/tables/fish_median_tsfeat_only.rds",
  "outputs/tables/fish_quintiles_allfreq_tsfeat_plus.rds",
  "outputs/tables/fish_quintiles_tsfeat_only_plus.rds",
  "outputs/tables/fish_median_allfreq_tsfeat_plus.rds",
  "outputs/tables/fish_median_tsfeat_only_plus.rds"
)

inv <- paths %>%
  map_dfr(brief) %>%
  mutate(
    variant = str_remove(file, "\\.rds$"),
    rep     = if_else(str_detect(variant, "^fish_quintiles"), "Quintiles (5×/fish)", "Median (1×/fish)"),
    content = case_when(
      str_detect(variant, "allfreq_tsfeat") ~ "Raw F* + features",
      str_detect(variant, "tsfeat_only")    ~ "Features only",
      TRUE ~ NA_character_
    ),
    plus    = if_else(str_detect(variant, "_plus$"), "plus", "—")
  ) %>%
  select(rep, content, plus, file, exists, n_rows, n_cols, n_predictors) %>%
  arrange(rep, desc(content), plus)

inv |>
  kbl(format = "latex", booktabs = TRUE, digits = 0,
      col.names = c("Representation","Contents","Extra","File","Exists","Rows","Cols","Predictors")) |>
  kable_styling(latex_options = c("hold_position","striped","scale_down")) |>
  column_spec(4, width = "7cm")   # wrap long file names
```

 @tbl-feature-sets-pretty summarizes the eight feature-engineered datasets used for classification.
“Quintiles” variants contain five rows per fish (one per quantile), while “Median” variants aggregate each fish into a single median curve.
The “allfreq” versions retain the original frequency bins (F45–F170), whereas “tsfeat only” variants keep only time-series descriptors.
“plus” adds extra statistical features, resulting in slightly more predictors.


#  Classification Methods



## **Overview and motivation**

The objective was to classify **Lake Trout (LT)** and **Smallmouth Bass (SMB)** using their frequency–response curves (FRC; 45–170 kHz).
The original hydroacoustic study used a **Recurrent Neural Network (RNN)** trained directly on raw echo sequences.
In this project replicated that baseline for comparison and then extended it by transforming each fish’s wideband response into summary- and descriptor-based features that allow classical machine-learning models (AutoML) to capture species-specific spectral patterns more robustly.

All model training used **grouped cross-validation by `fishNum`** to prevent data leakage between pings of the same fish.



## **Baseline: RNN replication**

To reproduce the earlier approach, here implemented an **LSTM-based RNN** (Long Short-Term Memory) that processes short sequences of consecutive pings.
Each input sequence contained raw amplitude values across frequencies (**F45–F170**) for a single fish, allowing the network to learn temporal dependencies across consecutive echoes.

```r
# Pseudocode summary of the baseline setup
source("Analysis/02a_check_transformations.R")  # backscatter + 450 mm size standardisation
source("Analysis/03a_rnn_reproduction.R")       # train/test LSTM sequence model
```

The RNN served purely as a **baseline** for sequence-level learning.
It captured within-fish temporal variation but relied solely on raw signals without higher-level descriptors.


## **AutoML on raw backscatter**

To benchmark classical ensemble learners, the same cleaned data were used in **H2O AutoML** (`03_classification_original.R`, `03b_automl_backscatter.R`).
Two configurations were tested:

1. **original** – per-ping input (raw frequencies);
2. **original_blocks** – five-ping block averages to smooth noise.

AutoML evaluated a diverse model stack (GBM, XGBoost, DRF, GLM, DeepLearning, Stacked Ensembles) with 20 % validation and 20 % test partitions.
Performance was summarised by AUC, log-loss, and accuracy at both the fixed 0.50 threshold and a *policy-adjusted* threshold (validation max-accuracy clipped to [0.40, 0.70]).


## **Fish-level feature-based AutoML (main analysis)**

The core analysis replaced raw pings with **fish-level summaries and descriptors** derived from the FRC shape.
Feature engineering scripts (`03b_features_fish_level.R`, `04_tsfeatures_build.R`, `04e_tsfeatures_plus.R`) generated eight model inputs:

| Representation         | Contents                 | Extra    |
| ---------------------- | ------------------------ | -------- |
| Quintiles (5 × / fish) | Raw F* + feasts features | — / plus |
| Median (1 × / fish)    | Raw F* + feasts features | — / plus |

Each fish’s FRC was treated as a short *pseudo-time series* across ordered frequencies.
This ordering enabled computation of **time-series descriptors** using:

* **`feasts`** – autocorrelation (ACF), partial ACF, seasonal STL, and spectral entropy
* **`tsfeatures`** – higher-order statistics such as entropy, lumpiness, stability, and unit-root tests

```r
# Example feature extraction step
tsib <- as_tsibble(fish_curve, index = freq_khz, key = fishNum)
features <- features(tsib, list(feat_acf, feat_pacf, feat_stl, feat_spectral))
```

AutoML (`05_automl_tsfeatures.R`, `05b_automl_tsfeatures_plus.R`) was then run separately for each variant.
Predictors for GLM and DeepLearning models were **centred and scaled within the training frame**, while tree-based models (GBM, XGBoost, DRF) used raw scales.



## **Model tuning and thresholding**

Targeted tuning followed three complementary scripts:

* `04c_freqselector.R` – diagnostic *Top-K* frequency selection via permutation importance
* `07_oof_threshold_tuning.R` – **out-of-fold** threshold estimation (train-only) to refine the policy threshold
* `08_grid_dl_features.R` – deep-learning grid search exploring activations, dropout, and hidden units

```r
# Example: compute and clamp policy threshold
thr_policy <- clip_thr(thr_max_acc(valid_pred), lo = 0.40, hi = 0.70)
```

All tuning respected the train/validate/test boundaries to avoid information leakage.



## **Reproducibility and outputs**

Each modelling stage automatically saved artefacts under `outputs/tables/` and `outputs/figures/`,
including leaderboards, JSON metrics, threshold logs, confusion matrices, and ROC plots.
Viewer scripts such as `view_results_tsfeatures.R` and `view_results_rnn.R` enable transparent re-inspection without rerunning models.



#  Results

```{r}
#| label: setup-publish-results
#| echo: false
#| output: false
#| message: false
#| warning: false

# ensure publish copies exist (idempotent)
dir.create(here::here("reports","tables"), showWarnings = FALSE, recursive = TRUE)
file.copy(here::here("outputs","tables","results_summary_latest_sorted.csv"),
          here::here("reports","tables","results_summary_latest_sorted.csv"), overwrite = TRUE)
file.copy(here::here("outputs","tables","threshold_policy_effects.csv"),
          here::here("reports","tables","threshold_policy_effects.csv"), overwrite = TRUE)

```


## **Feature importance: permutation on QUINTILES_ALLFREQ**

Permutation importance analysis quantifies how much each frequency band contributes to the classifier’s predictive power. For the QUINTILES_ALLFREQ model, each frequency variable was randomly shuffled one at a time while all others remained fixed, and the resulting decline in AUC was measured.

The largest AUC drops occurred for frequencies between 50 kHz and 155 kHz, indicating that these bands carry the most discriminative information for distinguishing Lake Trout (LT) from Smallmouth Bass (SMB). Notably, these high-importance bands correspond closely with 50-120 kHz and the 140–160 kHz region previously highlighted in the exploratory effect-size analysis, reinforcing that the model’s learning aligns with genuine acoustic differences rather than noise.

Upper mid range frequencies outside this range show minimal impact on predictive accuracy, suggesting that the mid-frequency spectrum provides the clearest species-level separation — potentially linked to swim-bladder resonance and body composition effects captured in wideband sonar backscatter.

```{r}
imp  <- read_csv(here::here("outputs","tables","varimp_quintiles_allfreq_permutation.csv"), show_col_types = FALSE)
topn <- slice_max(imp, auc_drop, n = 20)

ggplot(topn, ggplot2::aes(x = reorder(variable, auc_drop), y = auc_drop)) +
geom_col() +
coord_flip(clip = "off") +
labs(x = NULL, y = "AUC drop when shuffled",
title = "Frequency importance (permutation) — QUINTILES_ALLFREQ") +
theme_minimal(base_size = 13) +
scale_y_continuous(expand = ggplot2::expansion(mult = c(0, 0.02)))

```



## **Model comparison overview**

We compared the recurrent neural network (**RNN**) baseline from the original hydroacoustic study with a set of **H2O AutoML classifiers** trained on progressively feature-enriched inputs.
The four core variants were:

- **original_blocks**: raw frequency “blocks,” closest to the RNN baseline.

- **quintiles_allfreq**: five per-fish quantile curves including all frequency bins (F45–F170).

- **quintiles_feats**: quantile curves using only time-series descriptors.

- **median_allfreq**: single per-fish median curve with all frequencies.

Each model was evaluated on a **held-out test set** unseen during training.
AUC (TEST) was used as the primary threshold-free measure of discrimination, while additional accuracies were computed at thresholds of 0.50, raw validation-selected, and the final **policy-clipped** values.


```{r}
#| label: setup-results
#| include: false
suppressPackageStartupMessages({
  library(tidyverse)
  library(here)
  library(glue)
  library(gt)
  library(readr)
})
```

```{r}
#| label: load-results
#| message: false

library(here); library(readr); library(fs); library(dplyr)

# helper: pick the first existing path
first_existing <- function(...) {
  for (p in c(...)) if (file.exists(p)) return(p)
  stop("None of the expected files exist:\n", paste(c(...), collapse = "\n"))
}

# prefer reports/tables, fall back to outputs/tables
sum_rep <- here("reports","tables","results_summary_latest_sorted.csv")
sum_out <- here("outputs","tables","results_summary_latest_sorted.csv")
thr_rep <- here("reports","tables","threshold_policy_effects.csv")
thr_out <- here("outputs","tables","threshold_policy_effects.csv")

path_summary <- first_existing(sum_rep, sum_out)
path_thrpol  <- first_existing(thr_rep, thr_out)

# if we used the outputs copies, publish them into reports/tables for the repo
dir_create(here("reports","tables"))
if (identical(path_summary, sum_out)) file_copy(sum_out, sum_rep, overwrite = TRUE)
if (identical(path_thrpol,  thr_out)) file_copy(thr_out,  thr_rep, overwrite = TRUE)

# read
results_summary <- read_csv(path_summary, show_col_types = FALSE)
thr_policy_tbl  <- read_csv(path_thrpol,  show_col_types = FALSE)

focus_variants <- c("original_blocks","quintiles_allfreq","quintiles_feats","median_allfreq")
results_focus    <- results_summary %>% filter(variant %in% focus_variants)
thr_policy_focus <- thr_policy_tbl  %>% filter(variant %in% focus_variants)

```



## **Classification performance**

Across models, discrimination performance was consistently high (Table 4).
AUC (TEST) ranged from **0.93–0.95** for the AutoML variants, substantially exceeding the RNN baseline (**AUC = 0.84**).
Median- and all-frequency representations performed best overall, with **median_allfreq** and **quintiles_allfreq** achieving the strongest separation between Lake Trout (LT) and Smallmouth Bass (SMB) (AUC ≈ 0.95–1.00).

```{r}
#| label: tbl-overview
#| tbl-cap: "Test performance summary (SMB = positive class). We report threshold-free AUC (TEST) and thresholded accuracies at 0.50 and the policy threshold (raw, clipped to [0.40–0.70] if necessary)."
#| echo: false

# Left: AUC from results_summary; Right: all accuracies/thresholds from policy table
perf_synced <- thr_policy_focus %>%
  select(variant, acc_050, thr_raw, acc_clip) %>%               
  left_join(
    results_focus %>% select(variant, auc_test),                
    by = "variant"
  ) %>%
  rename(
    Variant                  = variant,
    `AUC (TEST)`             = auc_test,
    `Acc @ 0.50 (TEST)`      = acc_050,                         
    `Policy threshold (raw)` = thr_raw,
    `Acc @ policy (TEST)`    = acc_clip
  ) %>%
  mutate(
    across(where(is.numeric), ~ round(.x, 3))
  )

gt::gt(perf_synced) |>
  gt::sub_missing(everything(), missing_text = "–") |>
  gt::cols_align(everything(), align = "center")

```

*(Full results in `outputs/tables/threshold_policy_effects.csv`.)*


## **Effect of threshold policy**

Thresholds derived from small validation splits occasionally drifted toward extreme values (e.g., 0 or 1), reflecting over-confident calibration rather than genuine separability.

To standardise decision behaviour, we imposed a **policy window [0.40, 0.70]**:


$$
t_{\mathrm{clip}} = \min\!\bigl(\max(t_{\mathrm{raw}},\,0.40),\,0.70\bigr)
$$



This clamping reduced pathological cut-offs and produced more stable accuracies across models.
For example, original_blocks improved from 0.775 (@ 0.964) to **0.857 (@ 0.70)**, while others showed negligible change (|ΔAcc| ≤ 0.07).

Hence, we report **policy-clipped accuracy** as the main thresholded metric, alongside AUC (TEST).
The RNN baseline, evaluated only at 0.50, achieved **accuracy = 0.593**, serving as a fixed-threshold reference.

```{r}
#| label: tbl-threshold-policy
#| tbl-cap: "Effect of the [0.40, 0.70] threshold policy on TEST accuracy."
#| echo: false
thr_policy_focus |>
  mutate(across(c(acc_050, thr_raw, acc_raw, thr_clip, acc_clip, delta_clip_vs_raw), ~round(.x, 3))) |>
  rename(
    Variant = variant,
    `Acc @ 0.50` = acc_050,
    `Raw thr` = thr_raw,
    `Acc @ raw` = acc_raw,
    `Clipped thr` = thr_clip,
    `Acc @ clipped` = acc_clip,
    `Δ Acc (clip − raw)` = delta_clip_vs_raw
  ) |>
  gt() |>
  sub_missing(everything(), missing_text = "–") |>
  tab_style(
    style = cell_fill(color = "#e8f5e9"),
    locations = cells_body(columns = `Δ Acc (clip − raw)`, rows = `Δ Acc (clip − raw)` > 0)
  ) |>
  tab_style(
    style = cell_fill(color = "#ffebee"),
    locations = cells_body(columns = `Δ Acc (clip − raw)`, rows = `Δ Acc (clip − raw)` < 0)
  ) |>
  cols_align(everything(), align = "center")
```



## **Receiver-operating characteristics**

Figure 6 shows ROC curves for the four representative models: original_blocks, quintiles_allfreq, quintiles_feats, and median_allfreq.

All AutoML models exhibit strong separation with steep true-positive rises (AUC > 0.93), whereas the RNN curve is noticeably flatter (AUC = 0.84).

Among them, median_allfreq approaches perfect discrimination (AUC = 1.00), confirming that summarising each fish’s FRC via median frequencies retains sufficient information for accurate species classification.

```{r}
#| label: fig-rocs
#| fig-cap: "ROC curves for representative AutoML models (TEST split)."
#| fig-show: hold
#| echo: false

library(here)
library(fs)

src_dir <- here("outputs","figures_report")
dst_dir <- here("reports","figures")  # <-- put files where LaTeX will look
dir_create(dst_dir)

variants <- c("original_blocks","quintiles_allfreq","quintiles_feats","median_allfreq")

pick_newest <- function(dir, pattern_ci) {
  all <- dir_ls(dir, type = "file", recurse = FALSE)
  hits <- all[grepl(pattern_ci, path_file(all), ignore.case = TRUE)]
  if (!length(hits)) return(NA_character_)
  hits[which.max(file_info(hits)$modification_time)]
}

src_files <- vapply(
  variants,
  function(v) {
    prefix <- switch(v,
      "original_blocks"   = "roc_original_blocks",
      "quintiles_allfreq" = "roc_quintiles_allfreq",
      "quintiles_feats"   = "roc_quintiles_feats",
      "median_allfreq"    = "roc_median_allfreq"
    )
    pick_newest(src_dir, paste0("^", prefix, ".*\\.png$"))
  },
  character(1)
)

if (anyNA(src_files)) {
  missing <- variants[is.na(src_files)]
  avail <- path_file(dir_ls(src_dir, type = "file", recurse = FALSE))
  stop(
    "Missing ROC PNG(s) for: ",
    paste(missing, collapse = ", "),
    "\nLooked in: ", src_dir,
    "\nAvailable files:\n", paste0("  - ", avail, collapse = "\n")
  )
}

stable_files <- file.path(dst_dir, paste0("ROC_", variants, ".png"))
file_copy(src_files, stable_files, overwrite = TRUE)

# from the perspective of reports/, these are now "figures/..."
rel <- file.path("figures", paste0("ROC_", variants, ".png"))
stopifnot(all(file.exists(here("reports", rel))))
knitr::include_graphics(rel)

```

*(ROCs copied into `reports/figures/` as `ROC_original_blocks.png`, `ROC_quintiles_allfreq.png`, `ROC_quintiles_feats.png`, `ROC_median_allfreq.png`.)*



## Summary

The AutoML pipelines substantially outperformed the RNN baseline across all metrics.

Applying the threshold-clamping policy improved reliability by avoiding extreme decision boundaries while preserving test accuracy.

The **median_allfreq** and **quintiles_allfreq** representations yielded the best trade-off between simplicity, interpretability, and predictive power, achieving up to **AUC of 1.0 and Acc between 0.86–0.92** on the held-out test set.




#  Temporal & Spatial Insights


```{r}
#| label: fig-depth-dens
#| fig-cap: "Depth distributions by species (if `Target_true_depth` exists)."
#| fig-width: 6.5
#| fig-height: 4

if ("Target_true_depth" %in% names(fish_raw)) {
ggplot(fish_raw, aes(Target_true_depth, fill = species, colour = species)) +
geom_density(alpha = 0.25) +
labs(x = "Target true depth (m)", y = "Density") +
theme_minimal(base_size = 12) +
theme(legend.position = "bottom")
}

```

#  Discussion

#  Conclusion & Future Work

# References

# Appendices


```{r}
#| label: fig-pings-per-fish
#| fig-cap: "Distribution of pings per fish (by species)."
#| fig-width: 6
#| fig-height: 4


ggplot(pings_per_fish, aes(n_pings, fill = species)) +
geom_histogram(position = "identity", alpha = 0.55, bins = 30, colour = NA) +
labs(x = "Pings per fish", y = "Count") +
theme_minimal(base_size = 12) +
theme(legend.position = "bottom")

```


```{r}
#| label: fig-corr-heat
#| fig-cap: "Correlation heatmap of frequency columns (pooled across species)."
#| fig-width: 7
#| fig-height: 6
library(scales)

X <- fish_raw |> select(all_of(freq_cols)) |> drop_na()
R <- cor(X)
ord <- order(readr::parse_number(colnames(R)))
R <- R[ord, ord]

image(
1:ncol(R), 1:ncol(R), t(R[ncol(R):1, ]),
axes = FALSE, xlab = "", ylab = "", col = hcl.colors(50, "Blues 3")
)
axis(1, at = seq_len(ncol(R)), labels = colnames(R)[ord], las = 2, cex.axis = 0.6)
axis(2, at = seq_len(ncol(R)), labels = rev(colnames(R)[ord]), las = 2, cex.axis = 0.6)
box()

```

```{r}
#| label: fig-band-boxes
#| fig-cap: "Band-averaged TS by species (low: 50–90, mid: 90–130, high: 130–170 kHz)."
#| fig-width: 7
#| fig-height: 4.5

freq_num <- readr::parse_number(freq_cols)
bands <- tibble(col = freq_cols, f = freq_num) |>
mutate(band = case_when(
f >= 50  & f <  90  ~ "Low (50–90)",
f >= 90  & f < 130  ~ "Mid (90–130)",
f >= 130 & f <= 170 ~ "High (130–170)",
TRUE ~ "Other"
)) |>
filter(band != "Other")

band_means <- fish_raw |>
select(species, all_of(bands$col)) |>
pivot_longer(-species, names_to = "col", values_to = "TS") |>
left_join(bands, by = "col") |>
group_by(species, band) |>
summarise(TS = mean(TS, na.rm = TRUE), .groups = "drop")

ggplot(band_means, aes(band, TS, fill = species)) +
geom_col(position = position_dodge(width = 0.7)) +
labs(x = NULL, y = "Mean TS (dB)") +
theme_minimal(base_size = 12) +
theme(legend.position = "bottom")

```


```{r}
#| label: fig-outlier-rug
#| fig-cap: "Robust z-score of median FRC per fish (flag > |3|)."
#| fig-width: 6.2
#| fig-height: 4.2

robust_center <- function(x) median(x, na.rm = TRUE)
robust_scale  <- function(x) IQR(x, na.rm = TRUE) / 1.349

med_frc <- median_frc |> select(all_of(freq_cols))
z <- sweep(med_frc, 2, apply(med_frc, 2, robust_center), "-")
z <- sweep(z, 2, apply(med_frc, 2, robust_scale), "/")
z_any <- apply(abs(z), 1, max, na.rm = TRUE)

dfz <- tibble(fishNum = median_frc$fishNum, species = median_frc$species, zmax = z_any)

ggplot(dfz, aes(zmax, fill = species)) +
geom_histogram(bins = 30, alpha = 0.6, position = "identity", colour = NA) +
geom_vline(xintercept = 3, linetype = 2) +
labs(x = "Max robust |z| across F*", y = "Count") +
theme_minimal(base_size = 12) +
theme(legend.position = "bottom")

```